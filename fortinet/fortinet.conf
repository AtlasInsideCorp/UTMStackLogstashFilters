filter {
 #Check the minimum fields present in fortinet log, based in docs and samples provided
 #Were 100 different fields identified in official docs, plus the identified in real logs, below 6 are used to identify fortinet log
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/357866/log-message-fields
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/656858/log-id-definitions
 #Filter version 1.2.2
 
 if ( "date=" in [message] and "time=" in [message] and "logid=" in [message]
 and "type=" in [message] and "subtype=" in [message] and "level=" in [message]) { 

#......................................................................# 
 #First, replace whitespaces with default string after = to avoid kv issues, example:
 #device_id= date=2021-08-18, generates -> device_id="date=2021-08-18"
 #and should generate two fields: device_id and date
      mutate {
        gsub => [
          "message", "= ", "=X0X "
        ]
      }

#......................................................................#
#Using grok to parse priority if present
        grok {
 			match => {
 				"message" => [
				"(<%{NUMBER:priority}>)?%{GREEDYDATA:message_rest}"
 				]
 			}
 		}

#......................................................................#
#Using the kv filter with default config, usefull in key-value logs
 kv { source => "message_rest" }

#......................................................................#
#Remove fields that have issues with kv filter
   mutate {
      remove_field => ["msg"]
   }
#......................................................................#
#Using grok to parse kv issued fields
          grok {
            match => {
              "message_rest" => [
                 "%{GREEDYDATA} msg=%{QUOTEDSTRING:msg}%{GREEDYDATA}"
              ]
            }
          }
#......................................................................#
#Remove double quotation
          mutate {
            gsub => ["[msg]", '"', ""]
          }
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if devname field is present or if it has no value, in those
#cases datasource points to host field
 if ([devname]){
   if ([devname]=="X0X"){
    mutate {
     add_field => { "dataSource" => "%{host}" }
	}
	#Eliminating devname if it is present but has no value
	ruby { code => 'event.set("[devname]", nil)' }

   }else{
    mutate {
     add_field => { "dataSource" => "%{devname}" }
	}
   }
 }else{
    mutate {
     add_field => { "dataSource" => "%{host}" }
	}
 }
#......................................................................# 
#Generating dataType field required by CurrelationRulesEngine
   mutate {
		  add_field => {
			"dataType" => "firewall-fortigate-traffic"
		  }
	   }

#......................................................................#	   
#Formatting number values
   mutate {
      convert => {
        "priority" => "integer"
        "duration" => "integer"
        "sessionid" => "integer"
        "transport" => "integer"
        "srcport" => "integer"
        "srcserver" => "integer"
        "dstport" => "integer"
        "appid" => "integer"
        "countapp" => "integer"
        "rcvdbyte" => "integer"
        "rcvdpkt" => "integer"
        "rcvddelta" => "integer"
        "sentbyte" => "integer"
        "sentdelta" => "integer"
        "sentpkt" => "integer"
        "policyid" => "integer"
        "eventtime" => "integer"
        "proto" => "integer"
        "countdns" => "integer"
        "remport" => "integer"
        "locport" => "integer"
        }
   }

#......................................................................#
#Then add all possible fields to the json tree structure

   mutate { 
    rename => { "priority" => "[logx][fortigate][priority]" }
    rename => { "message" => "[logx][fortigate][message]" }
    rename => { "devname" => "[logx][fortigate][devname]" }
    rename => { "date" => "[logx][fortigate][date]" }
    rename => { "time" => "[logx][fortigate][time]" }
    rename => { "logid" => "[logx][fortigate][logid]" }
    rename => { "type" => "[logx][fortigate][type]" }
    rename => { "subtype" => "[logx][fortigate][subtype]" }
    rename => { "level" => "[logx][fortigate][level]" }
    rename => { "vd" => "[logx][fortigate][vd]" }
    rename => { "eventtime" => "[logx][fortigate][eventtime]" }
    rename => { "tz" => "[logx][fortigate][tz]" }
    rename => { "srcip" => "[logx][fortigate][src_ip]" }
    rename => { "srcport" => "[logx][fortigate][src_port]" }
    rename => { "srcintfrole" => "[logx][fortigate][srcintfrole]" }
    rename => { "dstip" => "[logx][fortigate][dest_ip]" }
    rename => { "dstport" => "[logx][fortigate][dest_port]" }
    rename => { "dstintf" => "[logx][fortigate][dstintf]" }
    rename => { "dstintfrole" => "[logx][fortigate][dstintfrole]" }
    rename => { "sessionid" => "[logx][fortigate][sessionid]" }
    rename => { "proto" => "[logx][fortigate][proto]" }
    rename => { "action" => "[logx][fortigate][action]" }
    rename => { "policyid" => "[logx][fortigate][policyid]" }
    rename => { "policytype" => "[logx][fortigate][policytype]" }
    rename => { "service" => "[logx][fortigate][service]" }
    rename => { "trandisp" => "[logx][fortigate][trandisp]" }
    rename => { "duration" => "[logx][fortigate][duration]" }
    rename => { "mastersrcmac" => "[logx][fortigate][mastersrcmac]" }
    rename => { "srcmac" => "[logx][fortigate][srcmac]" }
    rename => { "srcintf" => "[logx][fortigate][srcintf]" }
    rename => { "srcname" => "[logx][fortigate][srcname]" }
    rename => { "dstcountry" => "[logx][fortigate][dstcountry]" }
    rename => { "srccountry" => "[logx][fortigate][srccountry]" }
    rename => { "appid" => "[logx][fortigate][appid]" }
    rename => { "app" => "[logx][fortigate][app]" }
    rename => { "appcat" => "[logx][fortigate][appcat]" }
    rename => { "apprisk" => "[logx][fortigate][apprisk]" }
    rename => { "applist" => "[logx][fortigate][applist]" }
    rename => { "appact" => "[logx][fortigate][appact]" }
    rename => { "sentbyte" => "[logx][fortigate][sentbyte]" }
    rename => { "rcvdbyte" => "[logx][fortigate][rcvdbyte]" }
    rename => { "sentpkt" => "[logx][fortigate][sentpkt]" }
    rename => { "rcvdpkt" => "[logx][fortigate][rcvdpkt]" }
    rename => { "sentdelta" => "[logx][fortigate][sentdelta]" }
    rename => { "rcvddelta" => "[logx][fortigate][rcvddelta]" }
    rename => { "osname" => "[logx][fortigate][osname]" }
    rename => { "srcswversion" => "[logx][fortigate][srcswversion]" }
    rename => { "srchwversion" => "[logx][fortigate][srchwversion]" }
    rename => { "srcserver" => "[logx][fortigate][srcserver]" }
    rename => { "srchwvendor" => "[logx][fortigate][srchwvendor]" }
    rename => { "dsthwvendor" => "[logx][fortigate][dsthwvendor]" }
    rename => { "dstosname" => "[logx][fortigate][dstosname]" }
    rename => { "dstswversion" => "[logx][fortigate][dstswversion]" }
    rename => { "unauthuser" => "[logx][fortigate][unauthuser]" }
    rename => { "unauthusersource" => "[logx][fortigate][unauthusersource]" }
    rename => { "dstunauthuser" => "[logx][fortigate][dstunauthuser]" }
    rename => { "dstunauthusersource" => "[logx][fortigate][dstunauthusersource]" }
    rename => { "masterdstmac" => "[logx][fortigate][masterdstmac]" }
    rename => { "dstmac" => "[logx][fortigate][dstmac]" }
    rename => { "dstserver" => "[logx][fortigate][dstserver]" }
    rename => { "device_id" => "[logx][fortigate][device_id]" }
    rename => { "transip" => "[logx][fortigate][transip]" }
    rename => { "transport" => "[logx][fortigate][transport]" }
    rename => { "utmaction" => "[logx][fortigate][utmaction]" }
    rename => { "utmref" => "[logx][fortigate][utmref]" }
    rename => { "countdns" => "[logx][fortigate][countdns]" }
    rename => { "direction" => "[logx][fortigate][direction]" }
    rename => { "devtype" => "[logx][fortigate][devtype]" }
    rename => { "countapp" => "[logx][fortigate][countapp]" }
    rename => { "poluuid" => "[logx][fortigate][poluuid]" }
    rename => { "policymode" => "[logx][fortigate][policymode]" }
    rename => { "crscore" => "[logx][fortigate][crscore]" }
    rename => { "craction" => "[logx][fortigate][craction]" }
    rename => { "crlevel" => "[logx][fortigate][crlevel]" }
    rename => { "identifier" => "[logx][fortigate][identifier]" }
    rename => { "devid" => "[logx][fortigate][devid]" }

    #New fields detected in production logs
    rename => { "user" => "[logx][fortigate][user]" }
    rename => { "group" => "[logx][fortigate][group]" }
    rename => { "authserver" => "[logx][fortigate][authserver]" }
    rename => { "lanin" => "[logx][fortigate][lanin]" }
    rename => { "lanout" => "[logx][fortigate][lanout]" }
    rename => { "wanin" => "[logx][fortigate][wanin]" }
    rename => { "wanout" => "[logx][fortigate][wanout]" }
    rename => { "countweb" => "[logx][fortigate][countweb]" }
    rename => { "vpn" => "[logx][fortigate][vpn]" }
    rename => { "vpntype" => "[logx][fortigate][vpntype]" }
    rename => { "urlfilteridx" => "[logx][fortigate][urlfilteridx]" }
    rename => { "url" => "[logx][fortigate][url]" }
    rename => { "tranip" => "[logx][fortigate][tranip]" }
    rename => { "tranport" => "[logx][fortigate][tranport]" }
    rename => { "sslaction" => "[logx][fortigate][sslaction]" }
    rename => { "scertcname" => "[logx][fortigate][scertcname]" }
    rename => { "regtype" => "[logx][fortigate][regtype]" }
    rename => { "profile" => "[logx][fortigate][profile]" }
    rename => { "method" => "[logx][fortigate][method]" }
    rename => { "cat" => "[logx][fortigate][cat]" }
    rename => { "catdesc" => "[logx][fortigate][catdesc]" }
    rename => { "countav" => "[logx][fortigate][countav]" }
    rename => { "countdlp" => "[logx][fortigate][countdlp]" }
    rename => { "countips" => "[logx][fortigate][countips]" }
    rename => { "eventtype" => "[logx][fortigate][eventtype]" }
    rename => { "incidentserialno" => "[logx][fortigate][incidentserialno]" }
    rename => { "logdesc" => "[logx][fortigate][logdesc]" }

    #New fields in version 1.1.1
    rename => { "status" => "[logx][fortigate][status]" }
    rename => { "msg" => "[logx][fortigate][msg]" }
    rename => { "qname" => "[logx][fortigate][qname]" }
    rename => { "qclass" => "[logx][fortigate][qclass]" }
    rename => { "qtype" => "[logx][fortigate][qtype]" }
    rename => { "qtypeval" => "[logx][fortigate][qtypeval]" }
    rename => { "xid" => "[logx][fortigate][xid]" }
    rename => { "error" => "[logx][fortigate][error]" }
    rename => { "mode" => "[logx][fortigate][mode]" }
    rename => { "outintf" => "[logx][fortigate][outintf]" }
    rename => { "remip" => "[logx][fortigate][remip]" }
    rename => { "remport" => "[logx][fortigate][remport]" }
    rename => { "result" => "[logx][fortigate][result]" }
    rename => { "role" => "[logx][fortigate][role]" }
    rename => { "initiator" => "[logx][fortigate][initiator]" }
    rename => { "stage" => "[logx][fortigate][stage]" }
    rename => { "vpntunnel" => "[logx][fortigate][vpntunnel]" }
    rename => { "xauthuser" => "[logx][fortigate][xauthuser]" }
    rename => { "xauthgroup" => "[logx][fortigate][xauthgroup]" }
    rename => { "ui" => "[logx][fortigate][ui]" }
    rename => { "sn" => "[logx][fortigate][sn]" }
    rename => { "reason" => "[logx][fortigate][reason]" }
    rename => { "locport" => "[logx][fortigate][locport]" }
    rename => { "dir" => "[logx][fortigate][dir]" }
    rename => { "locip" => "[logx][fortigate][locip]" }
    rename => { "cookies" => "[logx][fortigate][cookies]" }
    rename => { "assignip" => "[logx][fortigate][assignip]" }
    rename => { "init" => "[logx][fortigate][init]" }
    rename => { "dst_host" => "[logx][fortigate][dst_host]" }
    rename => { "tunnelid" => "[logx][fortigate][tunnelid]" }
    rename => { "tunneltype" => "[logx][fortigate][tunneltype]" }
    rename => { "tunnelip" => "[logx][fortigate][tunnelip]" }
    rename => { "nextstat" => "[logx][fortigate][nextstat]" }
    rename => { "count" => "[logx][fortigate][count]" }
    rename => { "used_for_type" => "[logx][fortigate][used_for_type]" }
    rename => { "name" => "[logx][fortigate][name]" }
    rename => { "ip" => "[logx][fortigate][ip]" }
    rename => { "connection_type" => "[logx][fortigate][connection_type]" }
    rename => { "fctuid" => "[logx][fortigate][fctuid]" }
    rename => { "license_limit" => "[logx][fortigate][license_limit]" }
    rename => { "server" => "[logx][fortigate][server]" }
    rename => { "hostname" => "[logx][fortigate][hostname]" }
    rename => { "reqtype" => "[logx][fortigate][reqtype]" }
    rename => { "eventid" => "[logx][fortigate][eventid]" }
    rename => { "severity" => "[logx][fortigate][severity]" }
    rename => { "agent" => "[logx][fortigate][agent]" }
    rename => { "filesize" => "[logx][fortigate][filesize]" }
    rename => { "dlpextra" => "[logx][fortigate][dlpextra]" }
    rename => { "filename" => "[logx][fortigate][filename]" }
    rename => { "filteridx" => "[logx][fortigate][filteridx]" }
    rename => { "filtercat" => "[logx][fortigate][filtercat]" }
    rename => { "filtertype" => "[logx][fortigate][filtertype]" }
    rename => { "epoch" => "[logx][fortigate][epoch]" }
    rename => { "filetype" => "[logx][fortigate][filetype]" }

    #New fields in version 1.2.2
    rename => { "in_spi" => "[logx][fortigate][in_spi]" }
    rename => { "out_spi" => "[logx][fortigate][out_spi]" }
   }
   
   #Cleaning message field
   mutate {
      gsub => ["[logx][fortigate][message]", "X0X", ""]
   }

#......................................................................#
#Set null the fields with de X0X value (default string for null) 
            ruby {
                code => '
                    event.get("[logx][fortigate]").each do |k, v|
                          if (v == "X0X") 
                            event.set("[logx][fortigate][#{k}]",nil)
                          end
                       end   
                    '
            }
   
   #Generating action field for established connections
   #First for type traffic
   if ([logx][fortigate][type] == "traffic" and [logx][fortigate][action] != "deny") {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
   } 
   #Then for type event
   else if [logx][fortigate][type] == "event" { 
       #Subtype system
       if [logx][fortigate][subtype] == "system" 
       and ( ([logx][fortigate][action] == "login" and [logx][fortigate][status] == "success") or [logx][fortigate][action] == "logout" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       } 
       #Subtype vpn
       else if [logx][fortigate][subtype] == "vpn" 
       and ([logx][fortigate][action] == "negotiate" or [logx][fortigate][action] == "ssl-new-con" 
       or [logx][fortigate][action] == "install_sa" or [logx][fortigate][action] == "tunnel-stats"
       or [logx][fortigate][action] == "tunnel-up" or [logx][fortigate][action] == "tunnel-down"
       or [logx][fortigate][action] == "phase2-up" or [logx][fortigate][action] == "phase2-down") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype user
       else if [logx][fortigate][subtype] == "user" 
       and ("-logon" in [logx][fortigate][action] or "-logoff" in [logx][fortigate][action] 
       or "-logout" in [logx][fortigate][action] ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype endpoint
       else if [logx][fortigate][subtype] == "endpoint" 
       and ( [logx][fortigate][action] == "add" or [logx][fortigate][action] == "close" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for types or subtypes related to utm
   else if [logx][fortigate][type] == "utm" {
       #Subtype webfilter
       if [logx][fortigate][subtype] == "webfilter" 
       and ( [logx][fortigate][action] == "passthrough" or [logx][fortigate][action] == "allow" or [logx][fortigate][action] == "allowed" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       }
       #Subtype dlp
       else if [logx][fortigate][subtype] == "dlp" 
       and [logx][fortigate][action] != "block" and [logx][fortigate][action] != "drop" and [logx][fortigate][action] != "dropped" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","message_rest","tags"]
   }
 }
}
