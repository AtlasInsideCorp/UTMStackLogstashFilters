filter {
 #Check the minimum fields present in fortinet log, based in docs and samples provided
 #Were 100 different fields identified in official docs, plus the identified in real logs, below 6 are used to identify fortinet log
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/357866/log-message-fields
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/656858/log-id-definitions
 #Filter version 1.1.1
 
 if ( "date=" in [message] and "time=" in [message] and "logid=" in [message]
 and "type=" in [message] and "subtype=" in [message] and "level=" in [message]) { 

#......................................................................# 
 #First, replace whitespaces with default string after = to avoid kv issues, example:
 #device_id= date=2021-08-18, generates -> device_id="date=2021-08-18"
 #and should generate two fields: device_id and date
      mutate {
        gsub => [
          "message", "= ", "=X0X "
        ]
      }

#......................................................................#
#Using grok to parse priority if present
        grok {
 			match => {
 				"message" => [
				"(<%{NUMBER:priority}>)?%{GREEDYDATA:message_rest}"
 				]
 			}
 		}

#......................................................................#
#Using the kv filter with default config, usefull in key-value logs
 kv { source => "message_rest" }
 
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if devname field is present or if it has no value, in those
#cases datasource points to host field
 if ([devname]){
   if ([devname]=="X0X"){
    mutate {
     add_field => { "dataSource" => "%{host}" }
	}
	#Eliminating devname if it is present but has no value
	ruby { code => 'event.set("[devname]", nil)' }

   }else{
    mutate {
     add_field => { "dataSource" => "%{devname}" }
	}
   }
 }else{
    mutate {
     add_field => { "dataSource" => "%{host}" }
	}
 }
#......................................................................# 
#Generating dataType field required by CurrelationRulesEngine
   mutate {
		  add_field => {
			"dataType" => "firewall-fortigate-traffic"
		  }
	   }

#......................................................................#	   
#Formatting number values
   mutate {
      convert => {
        "priority" => "integer"
        "duration" => "integer"
        "sessionid" => "integer"
        "transport" => "integer"
        "srcport" => "integer"
        "srcserver" => "integer"
        "dstport" => "integer"
        "appid" => "integer"
        "countapp" => "integer"
        "rcvdbyte" => "integer"
        "rcvdpkt" => "integer"
        "rcvddelta" => "integer"
        "sentbyte" => "integer"
        "sentdelta" => "integer"
        "sentpkt" => "integer"
        "policyid" => "integer"
        "eventtime" => "integer"
        "proto" => "integer"
        "countdns" => "integer"
        "remport" => "integer"
        "locport" => "integer"
        }
   }
#......................................................................#
#The fields that contains the default string for null values "X0X"
#will be set to null
   
   if [date]=="X0X" {
	   ruby { code => 'event.set("[date]", nil)' }
   }
   if [time]=="X0X" {
	   ruby { code => 'event.set("[time]", nil)' }
   }
   if [logid]=="X0X" {
	   ruby { code => 'event.set("[logid]", nil)' }
   }
   if [type]=="X0X" {
	   ruby { code => 'event.set("[type]", nil)' }
   }
   if [subtype]=="X0X" {
	   ruby { code => 'event.set("[subtype]", nil)' }
   }
   if [level]=="X0X" {
	   ruby { code => 'event.set("[level]", nil)' }
   }
   if [vd]=="X0X" {
	   ruby { code => 'event.set("[vd]", nil)' }
   }
   if [eventtime]=="X0X" {
	   ruby { code => 'event.set("[eventtime]", nil)' }
   }
   if [tz]=="X0X" {
	   ruby { code => 'event.set("[tz]", nil)' }
   }
   if [srcip]=="X0X" {
	   ruby { code => 'event.set("[srcip]", nil)' }
   }
   if [srcport]=="X0X" {
	   ruby { code => 'event.set("[srcport]", nil)' }
   }
   if [srcintfrole]=="X0X" {
	   ruby { code => 'event.set("[srcintfrole]", nil)' }
   }
   if [dstip]=="X0X" {
	   ruby { code => 'event.set("[dstip]", nil)' }
   }
   if [dstport]=="X0X" {
	   ruby { code => 'event.set("[dstport]", nil)' }
   }
   if [dstintf]=="X0X" {
	   ruby { code => 'event.set("[dstintf]", nil)' }
   }
   if [dstintfrole]=="X0X" {
	   ruby { code => 'event.set("[dstintfrole]", nil)' }
   }
   if [sessionid]=="X0X" {
	   ruby { code => 'event.set("[sessionid]", nil)' }
   }
   if [proto]=="X0X" {
	   ruby { code => 'event.set("[proto]", nil)' }
   }
   if [action]=="X0X" {
	   ruby { code => 'event.set("[action]", nil)' }
   }
   if [policyid]=="X0X" {
	   ruby { code => 'event.set("[policyid]", nil)' }
   }
   if [policytype]=="X0X" {
	   ruby { code => 'event.set("[policytype]", nil)' }
   }
   if [service]=="X0X" {
	   ruby { code => 'event.set("[service]", nil)' }
   }
   if [trandisp]=="X0X" {
	   ruby { code => 'event.set("[trandisp]", nil)' }
   }
   if [duration]=="X0X" {
	   ruby { code => 'event.set("[duration]", nil)' }
   }
   if [mastersrcmac]=="X0X" {
	   ruby { code => 'event.set("[mastersrcmac]", nil)' }
   }
   if [srcmac]=="X0X" {
	   ruby { code => 'event.set("[srcmac]", nil)' }
   }
   if [srcintf]=="X0X" {
	   ruby { code => 'event.set("[srcintf]", nil)' }
   }
   if [srcname]=="X0X" {
	   ruby { code => 'event.set("[srcname]", nil)' }
   }
   if [dstcountry]=="X0X" {
	   ruby { code => 'event.set("[dstcountry]", nil)' }
   }
   if [srccountry]=="X0X" {
	   ruby { code => 'event.set("[srccountry]", nil)' }
   }
   if [appid]=="X0X" {
	   ruby { code => 'event.set("[appid]", nil)' }
   }
   if [app]=="X0X" {
	   ruby { code => 'event.set("[app]", nil)' }
   }
   if [appcat]=="X0X" {
	   ruby { code => 'event.set("[appcat]", nil)' }
   }
   if [apprisk]=="X0X" {
	   ruby { code => 'event.set("[apprisk]", nil)' }
   }
   if [applist]=="X0X" {
	   ruby { code => 'event.set("[applist]", nil)' }
   }
   if [appact]=="X0X" {
	   ruby { code => 'event.set("[appact]", nil)' }
   }
   if [sentbyte]=="X0X" {
	   ruby { code => 'event.set("[sentbyte]", nil)' }
   }
   if [rcvdbyte]=="X0X" {
	   ruby { code => 'event.set("[rcvdbyte]", nil)' }
   }
   if [sentpkt]=="X0X" {
	   ruby { code => 'event.set("[sentpkt]", nil)' }
   }
   if [rcvdpkt]=="X0X" {
	   ruby { code => 'event.set("[rcvdpkt]", nil)' }
   }
   if [sentdelta]=="X0X" {
	   ruby { code => 'event.set("[sentdelta]", nil)' }
   }
   if [rcvddelta]=="X0X" {
	   ruby { code => 'event.set("[rcvddelta]", nil)' }
   }
   if [osname]=="X0X" {
	   ruby { code => 'event.set("[osname]", nil)' }
   }
   if [srcswversion]=="X0X" {
	   ruby { code => 'event.set("[srcswversion]", nil)' }
   }
   if [srchwversion]=="X0X" {
	   ruby { code => 'event.set("[srchwversion]", nil)' }
   }
   if [srcserver]=="X0X" {
	   ruby { code => 'event.set("[srcserver]", nil)' }
   }
   if [srchwvendor]=="X0X" {
	   ruby { code => 'event.set("[srchwvendor]", nil)' }
   }
   if [dsthwvendor]=="X0X" {
	   ruby { code => 'event.set("[dsthwvendor]", nil)' }
   }
   if [dstosname]=="X0X" {
	   ruby { code => 'event.set("[dstosname]", nil)' }
   }
   if [dstswversion]=="X0X" {
	   ruby { code => 'event.set("[dstswversion]", nil)' }
   }
   if [unauthuser]=="X0X" {
	   ruby { code => 'event.set("[unauthuser]", nil)' }
   }
   if [unauthusersource]=="X0X" {
	   ruby { code => 'event.set("[unauthusersource]", nil)' }
   }
   if [dstunauthuser]=="X0X" {
	   ruby { code => 'event.set("[dstunauthuser]", nil)' }
   }
   if [dstunauthusersource]=="X0X" {
	   ruby { code => 'event.set("[dstunauthusersource]", nil)' }
   }
   if [masterdstmac]=="X0X" {
	   ruby { code => 'event.set("[masterdstmac]", nil)' }
   }
   if [dstmac]=="X0X" {
	   ruby { code => 'event.set("[dstmac]", nil)' }
   }
   if [dstserver]=="X0X" {
	   ruby { code => 'event.set("[dstserver]", nil)' }
   }
   if [device_id]=="X0X" {
	   ruby { code => 'event.set("[device_id]", nil)' }
   }
   if [transip]=="X0X" {
	   ruby { code => 'event.set("[transip]", nil)' }
   }
   if [transport]=="X0X" {
	   ruby { code => 'event.set("[transport]", nil)' }
   }
   if [utmaction]=="X0X" {
	   ruby { code => 'event.set("[utmaction]", nil)' }
   }
   if [utmref]=="X0X" {
	   ruby { code => 'event.set("[utmref]", nil)' }
   }
   if [countdns]=="X0X" {
	   ruby { code => 'event.set("[countdns]", nil)' }
   }
   if [direction]=="X0X" {
	   ruby { code => 'event.set("[direction]", nil)' }
   }
   if [devtype]=="X0X" {
	   ruby { code => 'event.set("[devtype]", nil)' }
   }
   if [countapp]=="X0X" {
	   ruby { code => 'event.set("[countapp]", nil)' }
   }
   if [poluuid]=="X0X" {
	   ruby { code => 'event.set("[poluuid]", nil)' }
   }
   if [policymode]=="X0X" {
	   ruby { code => 'event.set("[policymode]", nil)' }
   }
   if [crscore]=="X0X" {
	   ruby { code => 'event.set("[crscore]", nil)' }
   }
   if [craction]=="X0X" {
	   ruby { code => 'event.set("[craction]", nil)' }
   }
   if [crlevel]=="X0X" {
	   ruby { code => 'event.set("[crlevel]", nil)' }
   }
   if [identifier]=="X0X" {
	   ruby { code => 'event.set("[identifier]", nil)' }
   }
   if [devid]=="X0X" {
	   ruby { code => 'event.set("[devid]", nil)' }
   }
   if [user]=="X0X" {
	   ruby { code => 'event.set("[user]", nil)' }
   }
   if [group]=="X0X" {
	   ruby { code => 'event.set("[group]", nil)' }
   }
   if [authserver]=="X0X" {
	   ruby { code => 'event.set("[authserver]", nil)' }
   }
   if [lanin]=="X0X" {
	   ruby { code => 'event.set("[lanin]", nil)' }
   }
   if [lanout]=="X0X" {
	   ruby { code => 'event.set("[lanout]", nil)' }
   }
   if [wanin]=="X0X" {
	   ruby { code => 'event.set("[wanin]", nil)' }
   }
   if [wanout]=="X0X" {
	   ruby { code => 'event.set("[wanout]", nil)' }
   }
   if [countweb]=="X0X" {
	   ruby { code => 'event.set("[countweb]", nil)' }
   }
   if [vpn]=="X0X" {
	   ruby { code => 'event.set("[vpn]", nil)' }
   }
   if [vpntype]=="X0X" {
	   ruby { code => 'event.set("[vpntype]", nil)' }
   }
   if [urlfilteridx]=="X0X" {
	   ruby { code => 'event.set("[urlfilteridx]", nil)' }
   }
   if [url]=="X0X" {
	   ruby { code => 'event.set("[url]", nil)' }
   }
   if [tranip]=="X0X" {
	   ruby { code => 'event.set("[tranip]", nil)' }
   }
   if [tranport]=="X0X" {
	   ruby { code => 'event.set("[tranport]", nil)' }
   }
   if [sslaction]=="X0X" {
	   ruby { code => 'event.set("[sslaction]", nil)' }
   }
   if [scertcname]=="X0X" {
	   ruby { code => 'event.set("[scertcname]", nil)' }
   }
   if [regtype]=="X0X" {
	   ruby { code => 'event.set("[regtype]", nil)' }
   }
   if [profile]=="X0X" {
	   ruby { code => 'event.set("[profile]", nil)' }
   }
   if [method]=="X0X" {
	   ruby { code => 'event.set("[method]", nil)' }
   }
   if [cat]=="X0X" {
	   ruby { code => 'event.set("[cat]", nil)' }
   }
   if [catdesc]=="X0X" {
	   ruby { code => 'event.set("[catdesc]", nil)' }
   }
   if [countav]=="X0X" {
	   ruby { code => 'event.set("[countav]", nil)' }
   }
   if [countdlp]=="X0X" {
	   ruby { code => 'event.set("[countdlp]", nil)' }
   }
   if [countips]=="X0X" {
	   ruby { code => 'event.set("[countips]", nil)' }
   }
   if [eventtype]=="X0X" {
	   ruby { code => 'event.set("[eventtype]", nil)' }
   }
   if [incidentserialno]=="X0X" {
	   ruby { code => 'event.set("[incidentserialno]", nil)' }
   }
   if [logdesc]=="X0X" {
	   ruby { code => 'event.set("[logdesc]", nil)' }
   }
   #New fields in real logs, version 1.1.1
   if [status]=="X0X" {
	   ruby { code => 'event.set("[status]", nil)' }
   }
   if [msg]=="X0X" {
	   ruby { code => 'event.set("[msg]", nil)' }
   }
   if [qname]=="X0X" {
	   ruby { code => 'event.set("[qname]", nil)' }
   }
   if [qclass]=="X0X" {
	   ruby { code => 'event.set("[qclass]", nil)' }
   }
   if [qtype]=="X0X" {
	   ruby { code => 'event.set("[qtype]", nil)' }
   }
   if [qtypeval]=="X0X" {
	   ruby { code => 'event.set("[qtypeval]", nil)' }
   }
   if [xid]=="X0X" {
	   ruby { code => 'event.set("[xid]", nil)' }
   }
   if [error]=="X0X" {
	   ruby { code => 'event.set("[error]", nil)' }
   }
   if [mode]=="X0X" {
	   ruby { code => 'event.set("[mode]", nil)' }
   }
   if [outintf]=="X0X" {
	   ruby { code => 'event.set("[outintf]", nil)' }
   }
   if [remip]=="X0X" {
	   ruby { code => 'event.set("[remip]", nil)' }
   }
   if [remport]=="X0X" {
	   ruby { code => 'event.set("[remport]", nil)' }
   }
   if [result]=="X0X" {
	   ruby { code => 'event.set("[result]", nil)' }
   }
   if [role]=="X0X" {
	   ruby { code => 'event.set("[role]", nil)' }
   }
   if [initiator]=="X0X" {
	   ruby { code => 'event.set("[initiator]", nil)' }
   }
   if [stage]=="X0X" {
	   ruby { code => 'event.set("[stage]", nil)' }
   }
   if [vpntunnel]=="X0X" {
	   ruby { code => 'event.set("[vpntunnel]", nil)' }
   }
   if [xauthuser]=="X0X" {
	   ruby { code => 'event.set("[xauthuser]", nil)' }
   }
   if [xauthgroup]=="X0X" {
	   ruby { code => 'event.set("[xauthgroup]", nil)' }
   }
   if [ui]=="X0X" {
	   ruby { code => 'event.set("[ui]", nil)' }
   }
   if [sn]=="X0X" {
	   ruby { code => 'event.set("[sn]", nil)' }
   }
   if [reason]=="X0X" {
	   ruby { code => 'event.set("[reason]", nil)' }
   }
   if [locport]=="X0X" {
	   ruby { code => 'event.set("[locport]", nil)' }
   }
   if [dir]=="X0X" {
	   ruby { code => 'event.set("[dir]", nil)' }
   }
   if [locip]=="X0X" {
	   ruby { code => 'event.set("[locip]", nil)' }
   }
   if [cookies]=="X0X" {
	   ruby { code => 'event.set("[cookies]", nil)' }
   }
   if [assignip]=="X0X" {
	   ruby { code => 'event.set("[assignip]", nil)' }
   }
   if [init]=="X0X" {
	   ruby { code => 'event.set("[init]", nil)' }
   }
   if [dst_host]=="X0X" {
	   ruby { code => 'event.set("[dst_host]", nil)' }
   }
   if [tunnelid]=="X0X" {
	   ruby { code => 'event.set("[tunnelid]", nil)' }
   }
   if [tunneltype]=="X0X" {
	   ruby { code => 'event.set("[tunneltype]", nil)' }
   }
   if [tunnelip]=="X0X" {
	   ruby { code => 'event.set("[tunnelip]", nil)' }
   }
   if [nextstat]=="X0X" {
	   ruby { code => 'event.set("[nextstat]", nil)' }
   }
   if [count]=="X0X" {
	   ruby { code => 'event.set("[count]", nil)' }
   }
   if [used_for_type]=="X0X" {
	   ruby { code => 'event.set("[used_for_type]", nil)' }
   }
   if [name]=="X0X" {
	   ruby { code => 'event.set("[name]", nil)' }
   }
   if [ip]=="X0X" {
	   ruby { code => 'event.set("[ip]", nil)' }
   }
   if [connection_type]=="X0X" {
	   ruby { code => 'event.set("[connection_type]", nil)' }
   }
   if [fctuid]=="X0X" {
	   ruby { code => 'event.set("[fctuid]", nil)' }
   }
   if [license_limit]=="X0X" {
	   ruby { code => 'event.set("[license_limit]", nil)' }
   }
   if [server]=="X0X" {
	   ruby { code => 'event.set("[server]", nil)' }
   }
   if [hostname]=="X0X" {
	   ruby { code => 'event.set("[hostname]", nil)' }
   }
   if [reqtype]=="X0X" {
	   ruby { code => 'event.set("[reqtype]", nil)' }
   }
   if [eventid]=="X0X" {
	   ruby { code => 'event.set("[eventid]", nil)' }
   }
   if [severity]=="X0X" {
	   ruby { code => 'event.set("[severity]", nil)' }
   }
   if [agent]=="X0X" {
	   ruby { code => 'event.set("[agent]", nil)' }
   }
   if [filesize]=="X0X" {
	   ruby { code => 'event.set("[filesize]", nil)' }
   }
   if [dlpextra]=="X0X" {
	   ruby { code => 'event.set("[dlpextra]", nil)' }
   }
   if [filteridx]=="X0X" {
	   ruby { code => 'event.set("[filteridx]", nil)' }
   }
   if [filtercat]=="X0X" {
	   ruby { code => 'event.set("[filtercat]", nil)' }
   }
   if [filtertype]=="X0X" {
	   ruby { code => 'event.set("[filtertype]", nil)' }
   }
   if [epoch]=="X0X" {
	   ruby { code => 'event.set("[epoch]", nil)' }
   }
   if [filetype]=="X0X" {
	   ruby { code => 'event.set("[filetype]", nil)' }
   }
   if [filename]=="X0X" {
	   ruby { code => 'event.set("[filename]", nil)' }
   }
   
#......................................................................#
#Then add all possible fields to the json tree structure

   mutate { 
    rename => { "priority" => "[logx][fortigate][priority]" }
    rename => { "message" => "[logx][fortigate][message]" }
    rename => { "devname" => "[logx][fortigate][devname]" }
    rename => { "date" => "[logx][fortigate][date]" }
    rename => { "time" => "[logx][fortigate][time]" }
    rename => { "logid" => "[logx][fortigate][logid]" }
    rename => { "type" => "[logx][fortigate][type]" }
    rename => { "subtype" => "[logx][fortigate][subtype]" }
    rename => { "level" => "[logx][fortigate][level]" }
    rename => { "vd" => "[logx][fortigate][vd]" }
    rename => { "eventtime" => "[logx][fortigate][eventtime]" }
    rename => { "tz" => "[logx][fortigate][tz]" }
    rename => { "srcip" => "[logx][fortigate][src_ip]" }
    rename => { "srcport" => "[logx][fortigate][src_port]" }
    rename => { "srcintfrole" => "[logx][fortigate][srcintfrole]" }
    rename => { "dstip" => "[logx][fortigate][dest_ip]" }
    rename => { "dstport" => "[logx][fortigate][dest_port]" }
    rename => { "dstintf" => "[logx][fortigate][dstintf]" }
    rename => { "dstintfrole" => "[logx][fortigate][dstintfrole]" }
    rename => { "sessionid" => "[logx][fortigate][sessionid]" }
    rename => { "proto" => "[logx][fortigate][proto]" }
    rename => { "action" => "[logx][fortigate][action]" }
    rename => { "policyid" => "[logx][fortigate][policyid]" }
    rename => { "policytype" => "[logx][fortigate][policytype]" }
    rename => { "service" => "[logx][fortigate][service]" }
    rename => { "trandisp" => "[logx][fortigate][trandisp]" }
    rename => { "duration" => "[logx][fortigate][duration]" }
    rename => { "mastersrcmac" => "[logx][fortigate][mastersrcmac]" }
    rename => { "srcmac" => "[logx][fortigate][srcmac]" }
    rename => { "srcintf" => "[logx][fortigate][srcintf]" }
    rename => { "srcname" => "[logx][fortigate][srcname]" }
    rename => { "dstcountry" => "[logx][fortigate][dstcountry]" }
    rename => { "srccountry" => "[logx][fortigate][srccountry]" }
    rename => { "appid" => "[logx][fortigate][appid]" }
    rename => { "app" => "[logx][fortigate][app]" }
    rename => { "appcat" => "[logx][fortigate][appcat]" }
    rename => { "apprisk" => "[logx][fortigate][apprisk]" }
    rename => { "applist" => "[logx][fortigate][applist]" }
    rename => { "appact" => "[logx][fortigate][appact]" }
    rename => { "sentbyte" => "[logx][fortigate][sentbyte]" }
    rename => { "rcvdbyte" => "[logx][fortigate][rcvdbyte]" }
    rename => { "sentpkt" => "[logx][fortigate][sentpkt]" }
    rename => { "rcvdpkt" => "[logx][fortigate][rcvdpkt]" }
    rename => { "sentdelta" => "[logx][fortigate][sentdelta]" }
    rename => { "rcvddelta" => "[logx][fortigate][rcvddelta]" }
    rename => { "osname" => "[logx][fortigate][osname]" }
    rename => { "srcswversion" => "[logx][fortigate][srcswversion]" }
    rename => { "srchwversion" => "[logx][fortigate][srchwversion]" }
    rename => { "srcserver" => "[logx][fortigate][srcserver]" }
    rename => { "srchwvendor" => "[logx][fortigate][srchwvendor]" }
    rename => { "dsthwvendor" => "[logx][fortigate][dsthwvendor]" }
    rename => { "dstosname" => "[logx][fortigate][dstosname]" }
    rename => { "dstswversion" => "[logx][fortigate][dstswversion]" }
    rename => { "unauthuser" => "[logx][fortigate][unauthuser]" }
    rename => { "unauthusersource" => "[logx][fortigate][unauthusersource]" }
    rename => { "dstunauthuser" => "[logx][fortigate][dstunauthuser]" }
    rename => { "dstunauthusersource" => "[logx][fortigate][dstunauthusersource]" }
    rename => { "masterdstmac" => "[logx][fortigate][masterdstmac]" }
    rename => { "dstmac" => "[logx][fortigate][dstmac]" }
    rename => { "dstserver" => "[logx][fortigate][dstserver]" }
    rename => { "device_id" => "[logx][fortigate][device_id]" }
    rename => { "transip" => "[logx][fortigate][transip]" }
    rename => { "transport" => "[logx][fortigate][transport]" }
    rename => { "utmaction" => "[logx][fortigate][utmaction]" }
    rename => { "utmref" => "[logx][fortigate][utmref]" }
    rename => { "countdns" => "[logx][fortigate][countdns]" }
    rename => { "direction" => "[logx][fortigate][direction]" }
    rename => { "devtype" => "[logx][fortigate][devtype]" }
    rename => { "countapp" => "[logx][fortigate][countapp]" }
    rename => { "poluuid" => "[logx][fortigate][poluuid]" }
    rename => { "policymode" => "[logx][fortigate][policymode]" }
    rename => { "crscore" => "[logx][fortigate][crscore]" }
    rename => { "craction" => "[logx][fortigate][craction]" }
    rename => { "crlevel" => "[logx][fortigate][crlevel]" }
    rename => { "identifier" => "[logx][fortigate][identifier]" }
    rename => { "devid" => "[logx][fortigate][devid]" }

    #New fields detected in production logs
    rename => { "user" => "[logx][fortigate][user]" }
    rename => { "group" => "[logx][fortigate][group]" }
    rename => { "authserver" => "[logx][fortigate][authserver]" }
    rename => { "lanin" => "[logx][fortigate][lanin]" }
    rename => { "lanout" => "[logx][fortigate][lanout]" }
    rename => { "wanin" => "[logx][fortigate][wanin]" }
    rename => { "wanout" => "[logx][fortigate][wanout]" }
    rename => { "countweb" => "[logx][fortigate][countweb]" }
    rename => { "vpn" => "[logx][fortigate][vpn]" }
    rename => { "vpntype" => "[logx][fortigate][vpntype]" }
    rename => { "urlfilteridx" => "[logx][fortigate][urlfilteridx]" }
    rename => { "url" => "[logx][fortigate][url]" }
    rename => { "tranip" => "[logx][fortigate][tranip]" }
    rename => { "tranport" => "[logx][fortigate][tranport]" }
    rename => { "sslaction" => "[logx][fortigate][sslaction]" }
    rename => { "scertcname" => "[logx][fortigate][scertcname]" }
    rename => { "regtype" => "[logx][fortigate][regtype]" }
    rename => { "profile" => "[logx][fortigate][profile]" }
    rename => { "method" => "[logx][fortigate][method]" }
    rename => { "cat" => "[logx][fortigate][cat]" }
    rename => { "catdesc" => "[logx][fortigate][catdesc]" }
    rename => { "countav" => "[logx][fortigate][countav]" }
    rename => { "countdlp" => "[logx][fortigate][countdlp]" }
    rename => { "countips" => "[logx][fortigate][countips]" }
    rename => { "eventtype" => "[logx][fortigate][eventtype]" }
    rename => { "incidentserialno" => "[logx][fortigate][incidentserialno]" }
    rename => { "logdesc" => "[logx][fortigate][logdesc]" }

    #New fields in version 1.1.1
    rename => { "status" => "[logx][fortigate][status]" }
    rename => { "msg" => "[logx][fortigate][msg]" }
    rename => { "qname" => "[logx][fortigate][qname]" }
    rename => { "qclass" => "[logx][fortigate][qclass]" }
    rename => { "qtype" => "[logx][fortigate][qtype]" }
    rename => { "qtypeval" => "[logx][fortigate][qtypeval]" }
    rename => { "xid" => "[logx][fortigate][xid]" }
    rename => { "error" => "[logx][fortigate][error]" }
    rename => { "mode" => "[logx][fortigate][mode]" }
    rename => { "outintf" => "[logx][fortigate][outintf]" }
    rename => { "remip" => "[logx][fortigate][remip]" }
    rename => { "remport" => "[logx][fortigate][remport]" }
    rename => { "result" => "[logx][fortigate][result]" }
    rename => { "role" => "[logx][fortigate][role]" }
    rename => { "initiator" => "[logx][fortigate][initiator]" }
    rename => { "stage" => "[logx][fortigate][stage]" }
    rename => { "vpntunnel" => "[logx][fortigate][vpntunnel]" }
    rename => { "xauthuser" => "[logx][fortigate][xauthuser]" }
    rename => { "xauthgroup" => "[logx][fortigate][xauthgroup]" }
    rename => { "ui" => "[logx][fortigate][ui]" }
    rename => { "sn" => "[logx][fortigate][sn]" }
    rename => { "reason" => "[logx][fortigate][reason]" }
    rename => { "locport" => "[logx][fortigate][locport]" }
    rename => { "dir" => "[logx][fortigate][dir]" }
    rename => { "locip" => "[logx][fortigate][locip]" }
    rename => { "cookies" => "[logx][fortigate][cookies]" }
    rename => { "assignip" => "[logx][fortigate][assignip]" }
    rename => { "init" => "[logx][fortigate][init]" }
    rename => { "dst_host" => "[logx][fortigate][dst_host]" }
    rename => { "tunnelid" => "[logx][fortigate][tunnelid]" }
    rename => { "tunneltype" => "[logx][fortigate][tunneltype]" }
    rename => { "tunnelip" => "[logx][fortigate][tunnelip]" }
    rename => { "nextstat" => "[logx][fortigate][nextstat]" }
    rename => { "count" => "[logx][fortigate][count]" }
    rename => { "used_for_type" => "[logx][fortigate][used_for_type]" }
    rename => { "name" => "[logx][fortigate][name]" }
    rename => { "ip" => "[logx][fortigate][ip]" }
    rename => { "connection_type" => "[logx][fortigate][connection_type]" }
    rename => { "fctuid" => "[logx][fortigate][fctuid]" }
    rename => { "license_limit" => "[logx][fortigate][license_limit]" }
    rename => { "server" => "[logx][fortigate][server]" }
    rename => { "hostname" => "[logx][fortigate][hostname]" }
    rename => { "reqtype" => "[logx][fortigate][reqtype]" }
    rename => { "eventid" => "[logx][fortigate][eventid]" }
    rename => { "severity" => "[logx][fortigate][severity]" }
    rename => { "agent" => "[logx][fortigate][agent]" }
    rename => { "filesize" => "[logx][fortigate][filesize]" }
    rename => { "dlpextra" => "[logx][fortigate][dlpextra]" }
    rename => { "filename" => "[logx][fortigate][filename]" }
    rename => { "filteridx" => "[logx][fortigate][filteridx]" }
    rename => { "filtercat" => "[logx][fortigate][filtercat]" }
    rename => { "filtertype" => "[logx][fortigate][filtertype]" }
    rename => { "epoch" => "[logx][fortigate][epoch]" }
    rename => { "filetype" => "[logx][fortigate][filetype]" }
   }
   
   #Cleaning message field
   mutate {
      gsub => ["[logx][fortigate][message]", "X0X", ""]
   }
   
   #Generating action field for established connections
   #First for type traffic
   if ([logx][fortigate][type] == "traffic" and [logx][fortigate][action] != "deny") {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
   } 
   #Then for type event
   else if [logx][fortigate][type] == "event" { 
       #Subtype system
       if [logx][fortigate][subtype] == "system" 
       and ( ([logx][fortigate][action] == "login" and [logx][fortigate][status] == "success") or [logx][fortigate][action] == "logout" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       } 
       #Subtype vpn
       else if [logx][fortigate][subtype] == "vpn" 
       and ([logx][fortigate][action] == "negotiate" or [logx][fortigate][action] == "ssl-new-con" 
       or [logx][fortigate][action] == "install_sa" or [logx][fortigate][action] == "tunnel-stats"
       or [logx][fortigate][action] == "tunnel-up" or [logx][fortigate][action] == "tunnel-down"
       or [logx][fortigate][action] == "phase2-up" or [logx][fortigate][action] == "phase2-down") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype user
       else if [logx][fortigate][subtype] == "user" 
       and ("-logon" in [logx][fortigate][action] or "-logoff" in [logx][fortigate][action] 
       or "-logout" in [logx][fortigate][action] ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype endpoint
       else if [logx][fortigate][subtype] == "endpoint" 
       and ( [logx][fortigate][action] == "add" or [logx][fortigate][action] == "close" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for types or subtypes related to utm
   else if [logx][fortigate][type] == "utm" {
       #Subtype webfilter
       if [logx][fortigate][subtype] == "webfilter" 
       and ( [logx][fortigate][action] == "passthrough" or [logx][fortigate][action] == "allow" or [logx][fortigate][action] == "allowed" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }  
       }
       #Subtype dlp
       else if [logx][fortigate][subtype] == "dlp" 
       and [logx][fortigate][action] != "block" and [logx][fortigate][action] != "drop" and [logx][fortigate][action] != "dropped" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","message_rest"]
   }
 }
}
