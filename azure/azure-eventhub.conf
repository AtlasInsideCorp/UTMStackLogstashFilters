filter {
    #Fields where extracted based on https://docs.microsoft.com/en-us/azure/azure-monitor/essentials/activity-log
    #https://docs.microsoft.com/en-us/azure/azure-monitor/essentials/activity-log-schema

    json {
        source => "message"
    }
if [type] == "azure" {
    #Generating dataType and dataSource fields
        mutate {
            add_field => {
                "dataType" => "azure"
            }
            #Add based on metadata
            add_field => {
                "dataSource" => "%{[@metadata][dataSource]}"
            }
            add_field => {
                "[logx][tenant]" => "%{[@metadata][dataSource]}"
            }
        }
    #Generating JSON structure of logx.azure
    mutate {
            #First, fields without fields inside, from the log example,faltan los de la seg pagina
            rename => { "[message]" => "[logx][azure][message]" }
            rename => { "[id]" => "[logx][azure][id]" }
            rename => { "[eventType]" => "[logx][azure][eventType]" }
            rename => { "[subject]" => "[logx][azure][subject]" }
            rename => { "[eventTime]" => "[logx][azure][eventTime]" }
            rename => { "[topic]" => "[logx][azure][topic]" }

            #Then, fields inside [data] without fields inside, from the log example
            rename => { "[data][tenantId]" => "[logx][azure][tenantId]" }
            rename => { "[data][correlationId]" => "[logx][azure][correlationId]" }
            rename => { "[data][resourceUri]" => "[logx][azure][resourceUri]" }
            rename => { "[data][operationName]" => "[logx][azure][operationName]" }
            rename => { "[data][status]" => "[logx][azure][status]" }
            rename => { "[data][subscriptionId]" => "[logx][azure][subscriptionId]" }
            rename => { "[data][resourceProvider]" => "[logx][azure][resourceProvider]" }

            #Then fields in root level in the docs (first doc url), but not in the log examples, because operationName is inside [data]
            # and in the docs are root level, we asume that the other must come in the same way
            rename => { "[data][resourceId]" => "[logx][azure][resourceId]" }
            rename => { "[data][category]" => "[logx][azure][category]" }
            rename => { "[data][resultType]" => "[logx][azure][resultType]" }
            rename => { "[data][resultSignature]" => "[logx][azure][resultSignature]" }
            rename => { "[data][durationMs]" => "[logx][azure][durationMs]" }
            rename => { "[data][callerIpAddress]" => "[logx][azure][callerIpAddress]" }
            rename => { "[data][level]" => "[logx][azure][level]" }
            rename => { "[data][location]" => "[logx][azure][location]" }
            rename => { "[data][properties]" => "[logx][azure][properties]" }

            #Then fields in root level in the docs (second doc url), but not in the log examples, because operationName is inside [data]
            # and in the docs are root level, we asume that the other must come in the same way
            rename => { "[data][channels]" => "[logx][azure][channels]" }
            rename => { "[data][description]" => "[logx][azure][description]" }
            rename => { "[data][eventDataId]" => "[logx][azure][eventDataId]" }
            rename => { "[data][eventName]" => "[logx][azure][eventName]" }
            rename => { "[data][eventTimestamp]" => "[logx][azure][eventTimestamp]" }
            rename => { "[data][operationId]" => "[logx][azure][operationId]" }
            rename => { "[data][resourceGroupName]" => "[logx][azure][resourceGroupName]" }
            rename => { "[data][resourceProviderName]" => "[logx][azure][resourceProviderName]" }
            rename => { "[data][resourceType]" => "[logx][azure][resourceType]" }
            rename => { "[data][subStatus]" => "[logx][azure][subStatus]" }
            rename => { "[data][submissionTimestamp]" => "[logx][azure][submissionTimestamp]" }
            rename => { "[data][relatedEvents]" => "[logx][azure][relatedEvents]" }
            rename => { "[data][caller]" => "[logx][azure][caller]" }

            #Then, fields inside [data][authorization] without fields inside, from the log example
            rename => { "[data][authorization][scope]" => "[logx][azure][auth_scope]" }
            rename => { "[data][authorization][action]" => "[logx][azure][auth_action]" }

            #Then, fields inside [data][authorization][evidence], from the log example
            rename => { "[data][authorization][evidence][role]" => "[logx][azure][auth_evidence_role]" }
            rename => { "[data][authorization][evidence][roleAssignmentScope]" => "[logx][azure][auth_evidence_roleAssignmentScope]" }
            rename => { "[data][authorization][evidence][roleAssignmentId]" => "[logx][azure][auth_evidence_roleAssignmentId]" }
            rename => { "[data][authorization][evidence][principalId]" => "[logx][azure][auth_evidence_principalId]" }
            rename => { "[data][authorization][evidence][principalType]" => "[logx][azure][auth_evidence_principalType]" }
            rename => { "[data][authorization][evidence][roleDefinitionId]" => "[logx][azure][auth_evidence_roleDefinitionId]" }

            #Then, fields inside [data][claims], from the log example and match with docs at root level
            rename => { "[data][claims][aud]" => "[logx][azure][claims_aud]" }
            rename => { "[data][claims][iss]" => "[logx][azure][claims_iss]" }
            rename => { "[data][claims][iat]" => "[logx][azure][claims_iat]" }
            rename => { "[data][claims][nbf]" => "[logx][azure][claims_nbf]" }
            rename => { "[data][claims][exp]" => "[logx][azure][claims_exp]" }
            rename => { "[data][claims][ver]" => "[logx][azure][claims_ver]" }
            rename => { "[data][claims][http://schemas.microsoft.com/identity/claims/tenantid]" => "[logx][azure][claims_tenantid]" }
            rename => { "[data][claims][http://schemas.microsoft.com/claims/authnmethodsreferences]" => "[logx][azure][claims_authnmethodsreferences]" }
            rename => { "[data][claims][http://schemas.microsoft.com/identity/claims/objectidentifier]" => "[logx][azure][claims_objectidentifier]" }
            rename => { "[data][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn]" => "[logx][azure][claims_upn]" }
            rename => { "[data][claims][puid]" => "[logx][azure][claims_puid]" }
            rename => { "[data][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier]" => "[logx][azure][claims_nameidentifier]" }
            rename => { "[data][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname]" => "[logx][azure][claims_givenname]" }
            rename => { "[data][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname]" => "[logx][azure][claims_surname]" }
            rename => { "[data][claims][name]" => "[logx][azure][claims_name]" }
            rename => { "[data][claims][groups]" => "[logx][azure][claims_groups]" }
            rename => { "[data][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name]" => "[logx][azure][claims_identity_name]" }
            rename => { "[data][claims][appid]" => "[logx][azure][claims_appid]" }
            rename => { "[data][claims][http://schemas.microsoft.com/identity/claims/scope]" => "[logx][azure][claims_scope]" }
            rename => { "[data][claims][appidacr]" => "[logx][azure][claims_appidacr]" }
            rename => { "[data][claims][http://schemas.microsoft.com/claims/authnclassreference]" => "[logx][azure][claims_authnclassreference]" }

            #Then, fields inside [data][claims] not in doc but in log examples provided
            rename => { "[data][claims][ipaddr]" => "[logx][azure][claims_ipaddr]" }
            rename => { "[data][claims][xms_tcdt]" => "[logx][azure][claims_xms_tcdt]" }
            rename => { "[data][claims][rh]" => "[logx][azure][claims_rh]" }
            rename => { "[data][claims][aio]" => "[logx][azure][claims_aio]" }
            rename => { "[data][claims][uti]" => "[logx][azure][claims_uti]" }
    }

    #Finally remove unused fields 
    mutate {
        remove_field => ["path","@version","dataVersion","[data][time]","metadataVersion","type","data"]
    }
}
}